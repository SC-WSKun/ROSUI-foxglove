[
  {
      "id": 345,
      "name": "/is_path_valid",
      "requestSchema": "#Determine if the current path is still valid\n\nnav_msgs/Path path\n\n================================================================================\nMSG: nav_msgs/Path\n# An array of poses that represents a Path for a robot to follow.\n\n# Indicates the frame_id of the path.\nstd_msgs/Header header\n\n# Array of poses to follow.\ngeometry_msgs/PoseStamped[] poses\n\n================================================================================\nMSG: geometry_msgs/PoseStamped\n# A Pose with reference coordinate frame and timestamp\n\nstd_msgs/Header header\nPose pose\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of position and orientation.\n\nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data\n# in a particular coordinate frame.\n\n# Two-integer timestamp that is expressed as seconds and nanoseconds.\nbuiltin_interfaces/Time stamp\n\n# Transform frame with which this data is associated.\nstring frame_id\n\n================================================================================\nMSG: builtin_interfaces/Time\n# This message communicates ROS Time defined here:\n# https://design.ros2.org/articles/clock_and_time.html\n\n# The seconds component, valid over all int32 values.\nint32 sec\n\n# The nanoseconds component, valid in the range [0, 1e9).\nuint32 nanosec\n",
      "responseSchema": "\nbool is_valid\nint32[] invalid_pose_indices \n",
      "type": "nav2_msgs/srv/IsPathValid"
  },
  {
      "id": 290,
      "name": "/slam_toolbox/serialize_map",
      "requestSchema": "string filename\n",
      "responseSchema": "\n# Result code defintions\nuint8 RESULT_SUCCESS=0\nuint8 RESULT_FAILED_TO_WRITE_FILE=255\n\nuint8 result",
      "type": "slam_toolbox/srv/SerializePoseGraph"
  },
  {
      "id": 289,
      "name": "/slam_toolbox/save_map",
      "requestSchema": "std_msgs/String name\n\n================================================================================\nMSG: std_msgs/String\n# This was originally provided as an example message.\n# It is deprecated as of Foxy\n# It is recommended to create your own semantically meaningful message.\n# However if you would like to continue using this please use the equivalent in example_msgs.\n\nstring data\n",
      "responseSchema": "\n# Result code defintions\nuint8 RESULT_SUCCESS=0\nuint8 RESULT_NO_MAP_RECEIEVD=1\nuint8 RESULT_UNDEFINED_FAILURE=255\n\nuint8 result\n",
      "type": "slam_toolbox/srv/SaveMap"
  },
  {
      "id": 288,
      "name": "/slam_toolbox/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
  },
  {
      "id": 287,
      "name": "/slam_toolbox/deserialize_map",
      "requestSchema": "int8 UNSET = 0\nint8 START_AT_FIRST_NODE = 1\nint8 START_AT_GIVEN_POSE = 2\nint8 LOCALIZE_AT_POSE = 3\n\n# inital_pose should be Map -> base_frame (parameter, generally base_link)\n#\n\nstring filename\nint8 match_type\ngeometry_msgs/Pose2D initial_pose\n\n================================================================================\nMSG: geometry_msgs/Pose2D\n# Deprecated as of Foxy and will potentially be removed in any following release.\n# Please use the full 3D pose.\n\n# In general our recommendation is to use a full 3D representation of everything and for 2D specific applications make the appropriate projections into the plane for their calculations but optimally will preserve the 3D information during processing.\n\n# If we have parallel copies of 2D datatypes every UI and other pipeline will end up needing to have dual interfaces to plot everything. And you will end up with not being able to use 3D tools for 2D use cases even if they're completely valid, as you'd have to reimplement it with different inputs and outputs. It's not particularly hard to plot the 2D pose or compute the yaw error for the Pose message and there are already tools and libraries that can do this for you.# This expresses a position and orientation on a 2D manifold.\n\nfloat64 x\nfloat64 y\nfloat64 theta\n",
      "responseSchema": "",
      "type": "slam_toolbox/srv/DeserializePoseGraph"
  },
  {
      "id": 286,
      "name": "/slam_toolbox/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
  },
  {
      "id": 285,
      "name": "/transform_listener_impl_558d6aeaf0/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 284,
      "name": "/toggle",
      "requestSchema": "bool on\n",
      "responseSchema": "\nbool status\n",
      "type": "robot_localization/srv/ToggleFilterProcessing"
  },
  {
      "id": 283,
      "name": "/set_pose",
      "requestSchema": "geometry_msgs/PoseWithCovarianceStamped pose\n\n================================================================================\nMSG: geometry_msgs/PoseWithCovarianceStamped\n# This expresses an estimated pose with a reference coordinate frame and timestamp\n\nstd_msgs/Header header\nPoseWithCovariance pose\n\n================================================================================\nMSG: geometry_msgs/PoseWithCovariance\n# This represents a pose in free space with uncertainty.\n\nPose pose\n\n# Row-major representation of the 6x6 covariance matrix\n# The orientation parameters use a fixed-axis representation.\n# In order, the parameters are:\n# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)\nfloat64[36] covariance\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of position and orientation.\n\nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data\n# in a particular coordinate frame.\n\n# Two-integer timestamp that is expressed as seconds and nanoseconds.\nbuiltin_interfaces/Time stamp\n\n# Transform frame with which this data is associated.\nstring frame_id\n\n================================================================================\nMSG: builtin_interfaces/Time\n# This message communicates ROS Time defined here:\n# https://design.ros2.org/articles/clock_and_time.html\n\n# The seconds component, valid over all int32 values.\nint32 sec\n\n# The nanoseconds component, valid in the range [0, 1e9).\nuint32 nanosec\n",
      "responseSchema": "\n",
      "type": "robot_localization/srv/SetPose"
  },
  {
      "id": 282,
      "name": "/reset",
      "requestSchema": "",
      "responseSchema": "\n",
      "type": "std_srvs/srv/Empty"
  },
  {
      "id": 281,
      "name": "/enable",
      "requestSchema": "",
      "responseSchema": "\n",
      "type": "std_srvs/srv/Empty"
  },
  {
      "id": 280,
      "name": "/ekf_filter_node/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 279,
      "name": "/ekf_filter_node/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 278,
      "name": "/ekf_filter_node/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 277,
      "name": "/ekf_filter_node/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 276,
      "name": "/ekf_filter_node/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 275,
      "name": "/ekf_filter_node/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 274,
      "name": "/ekf_filter_node/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 272,
      "name": "/educar_base_controller/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 271,
      "name": "/educar_base_controller/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 270,
      "name": "/educar_base_controller/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 269,
      "name": "/educar_base_controller/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 268,
      "name": "/educar_base_controller/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 267,
      "name": "/educar_base_controller/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 266,
      "name": "/educar_base_controller/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 265,
      "name": "/szarbot_vel_mux/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 264,
      "name": "/szarbot_vel_mux/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 127,
      "name": "/lifecycle_manager_navigation/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 126,
      "name": "/lifecycle_manager_navigation/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 125,
      "name": "/lifecycle_manager_navigation/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 124,
      "name": "/global_costmap/global_costmap/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 123,
      "name": "/global_costmap/global_costmap/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 122,
      "name": "/global_costmap/global_costmap/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 121,
      "name": "/global_costmap/global_costmap/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 120,
      "name": "/global_costmap/global_costmap/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 119,
      "name": "/global_costmap/global_costmap/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
  },
  {
      "id": 118,
      "name": "/global_costmap/global_costmap/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 117,
      "name": "/global_costmap/global_costmap/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 116,
      "name": "/global_costmap/global_costmap/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 115,
      "name": "/global_costmap/global_costmap/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
  },
  {
      "id": 114,
      "name": "/global_costmap/global_costmap/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 113,
      "name": "/global_costmap/global_costmap/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
  },
  {
      "id": 112,
      "name": "/controller_server/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 111,
      "name": "/controller_server/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 110,
      "name": "/controller_server/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 109,
      "name": "/controller_server/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 108,
      "name": "/controller_server/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 107,
      "name": "/controller_server/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
  },
  {
      "id": 106,
      "name": "/controller_server/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 105,
      "name": "/controller_server/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 104,
      "name": "/controller_server/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 103,
      "name": "/controller_server/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
  },
  {
      "id": 102,
      "name": "/controller_server/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 101,
      "name": "/controller_server/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
  },
  {
      "id": 100,
      "name": "/bt_navigator/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 99,
      "name": "/bt_navigator/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 98,
      "name": "/bt_navigator/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 97,
      "name": "/bt_navigator/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 96,
      "name": "/bt_navigator/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 95,
      "name": "/bt_navigator/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
  },
  {
      "id": 94,
      "name": "/bt_navigator/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 93,
      "name": "/bt_navigator/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 92,
      "name": "/bt_navigator/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 91,
      "name": "/bt_navigator/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
  },
  {
      "id": 90,
      "name": "/bt_navigator/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 89,
      "name": "/bt_navigator/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
  },
  {
      "id": 88,
      "name": "/behavior_server/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 87,
      "name": "/behavior_server/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 86,
      "name": "/behavior_server/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 85,
      "name": "/behavior_server/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 84,
      "name": "/behavior_server/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 83,
      "name": "/behavior_server/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
  },
  {
      "id": 82,
      "name": "/behavior_server/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 81,
      "name": "/behavior_server/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 80,
      "name": "/behavior_server/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 79,
      "name": "/behavior_server/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
  },
  {
      "id": 78,
      "name": "/behavior_server/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 77,
      "name": "/behavior_server/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
  },
  {
      "id": 76,
      "name": "/tiered_nav_state_machine/switch_mode",
      "requestSchema": "uint8 MODE_IDLE = 0\nuint8 MODE_MAPPING = 1\nuint8 MODE_LOCALIZATION = 2\nuint8 MODE_QUERY = 255\n\nuint8 mode\nuint8 map_type # map type in mapping mode\n",
      "responseSchema": "\nuint8 current_mode\nbool result",
      "type": "gch_tiered_nav/srv/SwitchMode"
  },
  {
      "id": 75,
      "name": "/tiered_nav_state_machine/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 74,
      "name": "/tiered_nav_state_machine/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 73,
      "name": "/tiered_nav_state_machine/save_map",
      "requestSchema": "string name\n",
      "responseSchema": "\nbool result\n",
      "type": "gch_tiered_nav/srv/SaveMap"
  },
  {
      "id": 72,
      "name": "/tiered_nav_state_machine/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 71,
      "name": "/tiered_nav_state_machine/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 70,
      "name": "/tiered_nav_state_machine/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 69,
      "name": "/tiered_nav_state_machine/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 68,
      "name": "/tiered_nav_state_machine/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 67,
      "name": "/szarbot_safety_controller/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 66,
      "name": "/szarbot_safety_controller/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 65,
      "name": "/szarbot_safety_controller/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 64,
      "name": "/szarbot_safety_controller/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 63,
      "name": "/szarbot_safety_controller/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 62,
      "name": "/szarbot_safety_controller/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 61,
      "name": "/szarbot_control/bus_op",
      "requestSchema": "uint8 bus_id\nuint8 recv_len\nuint8[] data\n",
      "responseSchema": "\nbool success\nuint8[] data",
      "type": "szarbot_control/srv/BusOp"
  },
  {
      "id": 60,
      "name": "/szarbot_container/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 29,
      "name": "/EduCar_srvclient/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 28,
      "name": "/EduCar_srvclient/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 27,
      "name": "/EduCar_srvclient/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 26,
      "name": "/EduCar_srvclient/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 25,
      "name": "/EduCar_srvclient/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 24,
      "name": "/EduCar_srvclient/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 23,
      "name": "/EduCar_srvclient/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 22,
      "name": "/launch_ros_102/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 21,
      "name": "/launch_ros_102/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 20,
      "name": "/launch_ros_102/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 19,
      "name": "/launch_ros_102/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 18,
      "name": "/launch_ros_102/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 17,
      "name": "/launch_ros_102/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 16,
      "name": "/launch_ros_102/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 15,
      "name": "/launch_ros_100/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 14,
      "name": "/launch_ros_100/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 1,
      "name": "/foxglove_bridge/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 258,
      "name": "/joint_state_broadcaster/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 2,
      "name": "/foxglove_bridge/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 259,
      "name": "/szarbot_vel_mux/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 3,
      "name": "/foxglove_bridge/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 260,
      "name": "/szarbot_vel_mux/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 4,
      "name": "/foxglove_bridge/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 261,
      "name": "/szarbot_vel_mux/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 5,
      "name": "/foxglove_bridge/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 262,
      "name": "/szarbot_vel_mux/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 6,
      "name": "/foxglove_bridge/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 263,
      "name": "/szarbot_vel_mux/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 7,
      "name": "/foxglove_bridge/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 8,
      "name": "/foxglove_bridge_component_manager/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 9,
      "name": "/launch_ros_100/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 10,
      "name": "/launch_ros_100/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 11,
      "name": "/launch_ros_100/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 12,
      "name": "/launch_ros_100/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 13,
      "name": "/launch_ros_100/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 30,
      "name": "/camera/gscam_publisher/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 31,
      "name": "/camera/gscam_publisher/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 32,
      "name": "/camera/gscam_publisher/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 33,
      "name": "/camera/gscam_publisher/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 34,
      "name": "/camera/gscam_publisher/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 35,
      "name": "/camera/gscam_publisher/set_camera_info",
      "requestSchema": "# This service requests that a camera stores the given CameraInfo as that\n# camera's calibration information.\n#\n# The width and height in the camera_info field should match what the\n# camera is currently outputting on its camera_info topic, and the camera\n# will assume that the region of the imager that is being referred to is\n# the region that the camera is currently capturing.\n\nsensor_msgs/CameraInfo camera_info # The camera_info to store\n\n================================================================================\nMSG: sensor_msgs/CameraInfo\n# This message defines meta information for a camera. It should be in a\n# camera namespace on topic \"camera_info\" and accompanied by up to five\n# image topics named:\n#\n#   image_raw - raw data from the camera driver, possibly Bayer encoded\n#   image            - monochrome, distorted\n#   image_color      - color, distorted\n#   image_rect       - monochrome, rectified\n#   image_rect_color - color, rectified\n#\n# The image_pipeline contains packages (image_proc, stereo_image_proc)\n# for producing the four processed image topics from image_raw and\n# camera_info. The meaning of the camera parameters are described in\n# detail at http://www.ros.org/wiki/image_pipeline/CameraInfo.\n#\n# The image_geometry package provides a user-friendly interface to\n# common operations using this meta information. If you want to, e.g.,\n# project a 3d point into image coordinates, we strongly recommend\n# using image_geometry.\n#\n# If the camera is uncalibrated, the matrices D, K, R, P should be left\n# zeroed out. In particular, clients may assume that K[0] == 0.0\n# indicates an uncalibrated camera.\n\n#######################################################################\n#                     Image acquisition info                          #\n#######################################################################\n\n# Time of image acquisition, camera coordinate frame ID\nstd_msgs/Header header # Header timestamp should be acquisition time of image\n                             # Header frame_id should be optical frame of camera\n                             # origin of frame should be optical center of camera\n                             # +x should point to the right in the image\n                             # +y should point down in the image\n                             # +z should point into the plane of the image\n\n\n#######################################################################\n#                      Calibration Parameters                         #\n#######################################################################\n# These are fixed during camera calibration. Their values will be the #\n# same in all messages until the camera is recalibrated. Note that    #\n# self-calibrating systems may \"recalibrate\" frequently.              #\n#                                                                     #\n# The internal parameters can be used to warp a raw (distorted) image #\n# to:                                                                 #\n#   1. An undistorted image (requires D and K)                        #\n#   2. A rectified image (requires D, K, R)                           #\n# The projection matrix P projects 3D points into the rectified image.#\n#######################################################################\n\n# The image dimensions with which the camera was calibrated.\n# Normally this will be the full camera resolution in pixels.\nuint32 height\nuint32 width\n\n# The distortion model used. Supported models are listed in\n# sensor_msgs/distortion_models.hpp. For most cameras, \"plumb_bob\" - a\n# simple model of radial and tangential distortion - is sufficent.\nstring distortion_model\n\n# The distortion parameters, size depending on the distortion model.\n# For \"plumb_bob\", the 5 parameters are: (k1, k2, t1, t2, k3).\nfloat64[] d\n\n# Intrinsic camera matrix for the raw (distorted) images.\n#     [fx  0 cx]\n# K = [ 0 fy cy]\n#     [ 0  0  1]\n# Projects 3D points in the camera coordinate frame to 2D pixel\n# coordinates using the focal lengths (fx, fy) and principal point\n# (cx, cy).\nfloat64[9]  k # 3x3 row-major matrix\n\n# Rectification matrix (stereo cameras only)\n# A rotation matrix aligning the camera coordinate system to the ideal\n# stereo image plane so that epipolar lines in both stereo images are\n# parallel.\nfloat64[9]  r # 3x3 row-major matrix\n\n# Projection/camera matrix\n#     [fx'  0  cx' Tx]\n# P = [ 0  fy' cy' Ty]\n#     [ 0   0   1   0]\n# By convention, this matrix specifies the intrinsic (camera) matrix\n#  of the processed (rectified) image. That is, the left 3x3 portion\n#  is the normal camera intrinsic matrix for the rectified image.\n# It projects 3D points in the camera coordinate frame to 2D pixel\n#  coordinates using the focal lengths (fx', fy') and principal point\n#  (cx', cy') - these may differ from the values in K.\n# For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will\n#  also have R = the identity and P[1:3,1:3] = K.\n# For a stereo pair, the fourth column [Tx Ty 0]' is related to the\n#  position of the optical center of the second camera in the first\n#  camera's frame. We assume Tz = 0 so both cameras are in the same\n#  stereo image plane. The first camera always has Tx = Ty = 0. For\n#  the right (second) camera of a horizontal stereo pair, Ty = 0 and\n#  Tx = -fx' * B, where B is the baseline between the cameras.\n# Given a 3D point [X Y Z]', the projection (x, y) of the point onto\n#  the rectified image is given by:\n#  [u v w]' = P * [X Y Z 1]'\n#         x = u / w\n#         y = v / w\n#  This holds for both images of a stereo pair.\nfloat64[12] p # 3x4 row-major matrix\n\n\n#######################################################################\n#                      Operational Parameters                         #\n#######################################################################\n# These define the image region actually captured by the camera       #\n# driver. Although they affect the geometry of the output image, they #\n# may be changed freely without recalibrating the camera.             #\n#######################################################################\n\n# Binning refers here to any camera setting which combines rectangular\n#  neighborhoods of pixels into larger \"super-pixels.\" It reduces the\n#  resolution of the output image to\n#  (width / binning_x) x (height / binning_y).\n# The default values binning_x = binning_y = 0 is considered the same\n#  as binning_x = binning_y = 1 (no subsampling).\nuint32 binning_x\nuint32 binning_y\n\n# Region of interest (subwindow of full camera resolution), given in\n#  full resolution (unbinned) image coordinates. A particular ROI\n#  always denotes the same window of pixels on the camera sensor,\n#  regardless of binning settings.\n# The default setting of roi (all values 0) is considered the same as\n#  full resolution (roi.width = width, roi.height = height).\nRegionOfInterest roi\n\n================================================================================\nMSG: sensor_msgs/RegionOfInterest\n# This message is used to specify a region of interest within an image.\n#\n# When used to specify the ROI setting of the camera when the image was\n# taken, the height and width fields should either match the height and\n# width fields for the associated image; or height = width = 0\n# indicates that the full resolution image was captured.\n\nuint32 x_offset  # Leftmost pixel of the ROI\n                 # (0 if the ROI includes the left edge of the image)\nuint32 y_offset  # Topmost pixel of the ROI\n                 # (0 if the ROI includes the top edge of the image)\nuint32 height    # Height of ROI\nuint32 width     # Width of ROI\n\n# True if a distinct rectified ROI should be calculated from the \"raw\"\n# ROI in this message. Typically this should be False if the full image\n# is captured (ROI not used), and True if a subwindow is captured (ROI\n# used).\nbool do_rectify\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data\n# in a particular coordinate frame.\n\n# Two-integer timestamp that is expressed as seconds and nanoseconds.\nbuiltin_interfaces/Time stamp\n\n# Transform frame with which this data is associated.\nstring frame_id\n\n================================================================================\nMSG: builtin_interfaces/Time\n# This message communicates ROS Time defined here:\n# https://design.ros2.org/articles/clock_and_time.html\n\n# The seconds component, valid over all int32 values.\nint32 sec\n\n# The nanoseconds component, valid in the range [0, 1e9).\nuint32 nanosec\n",
      "responseSchema": "\nbool success                             # True if the call succeeded\nstring status_message                    # Used to give details about success\n",
      "type": "sensor_msgs/srv/SetCameraInfo"
  },
  {
      "id": 36,
      "name": "/camera/gscam_publisher/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 37,
      "name": "/camera/gscam_publisher/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 38,
      "name": "/controller_manager/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 39,
      "name": "/controller_manager/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 40,
      "name": "/controller_manager/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 41,
      "name": "/controller_manager/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 42,
      "name": "/controller_manager/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 43,
      "name": "/controller_manager/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 44,
      "name": "/controller_manager/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 45,
      "name": "/lsn10p/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 46,
      "name": "/lsn10p/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 47,
      "name": "/lsn10p/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 48,
      "name": "/lsn10p/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 49,
      "name": "/lsn10p/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 50,
      "name": "/lsn10p/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 51,
      "name": "/lsn10p/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 52,
      "name": "/nav2_container/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 53,
      "name": "/robot_state_publisher/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 54,
      "name": "/robot_state_publisher/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 55,
      "name": "/robot_state_publisher/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 56,
      "name": "/robot_state_publisher/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 57,
      "name": "/robot_state_publisher/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 58,
      "name": "/robot_state_publisher/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 59,
      "name": "/robot_state_publisher/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 128,
      "name": "/lifecycle_manager_navigation/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 129,
      "name": "/lifecycle_manager_navigation/is_active",
      "requestSchema": "",
      "responseSchema": "\nbool success   # indicate successful run of triggered service\nstring message # informational, e.g. for error messages\n",
      "type": "std_srvs/srv/Trigger"
  },
  {
      "id": 130,
      "name": "/lifecycle_manager_navigation/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 131,
      "name": "/lifecycle_manager_navigation/manage_nodes",
      "requestSchema": "uint8 STARTUP = 0\nuint8 PAUSE = 1\nuint8 RESUME = 2\nuint8 RESET = 3\nuint8 SHUTDOWN = 4\n\nuint8 command\n",
      "responseSchema": "\nbool success\n",
      "type": "nav2_msgs/srv/ManageLifecycleNodes"
  },
  {
      "id": 132,
      "name": "/lifecycle_manager_navigation/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 133,
      "name": "/lifecycle_manager_navigation/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 134,
      "name": "/local_costmap/local_costmap/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
  },
  {
      "id": 135,
      "name": "/local_costmap/local_costmap/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 136,
      "name": "/local_costmap/local_costmap/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
  },
  {
      "id": 137,
      "name": "/local_costmap/local_costmap/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 138,
      "name": "/local_costmap/local_costmap/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 139,
      "name": "/local_costmap/local_costmap/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 140,
      "name": "/local_costmap/local_costmap/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
  },
  {
      "id": 141,
      "name": "/local_costmap/local_costmap/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 142,
      "name": "/local_costmap/local_costmap/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 143,
      "name": "/local_costmap/local_costmap/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 144,
      "name": "/local_costmap/local_costmap/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 145,
      "name": "/local_costmap/local_costmap/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 146,
      "name": "/planner_server/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
  },
  {
      "id": 147,
      "name": "/planner_server/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 148,
      "name": "/planner_server/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
  },
  {
      "id": 149,
      "name": "/planner_server/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 150,
      "name": "/planner_server/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 151,
      "name": "/planner_server/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 152,
      "name": "/planner_server/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
  },
  {
      "id": 153,
      "name": "/planner_server/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 154,
      "name": "/planner_server/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 155,
      "name": "/planner_server/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 156,
      "name": "/planner_server/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 157,
      "name": "/planner_server/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 158,
      "name": "/smart_teleop/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
  },
  {
      "id": 159,
      "name": "/smart_teleop/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 160,
      "name": "/smart_teleop/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
  },
  {
      "id": 161,
      "name": "/smart_teleop/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 162,
      "name": "/smart_teleop/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 163,
      "name": "/smart_teleop/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 164,
      "name": "/smart_teleop/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
  },
  {
      "id": 165,
      "name": "/smart_teleop/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 166,
      "name": "/smart_teleop/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 167,
      "name": "/smart_teleop/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 168,
      "name": "/smart_teleop/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 169,
      "name": "/smart_teleop/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 170,
      "name": "/smoother_server/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
  },
  {
      "id": 171,
      "name": "/smoother_server/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 172,
      "name": "/smoother_server/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
  },
  {
      "id": 173,
      "name": "/smoother_server/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 174,
      "name": "/smoother_server/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 175,
      "name": "/smoother_server/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 176,
      "name": "/smoother_server/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
  },
  {
      "id": 177,
      "name": "/smoother_server/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 178,
      "name": "/smoother_server/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 179,
      "name": "/smoother_server/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 180,
      "name": "/smoother_server/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 181,
      "name": "/smoother_server/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 189,
      "name": "/szarbot_control/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 190,
      "name": "/szarbot_control/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 191,
      "name": "/szarbot_control/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 192,
      "name": "/szarbot_control/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 193,
      "name": "/szarbot_control/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 194,
      "name": "/szarbot_control/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 195,
      "name": "/szarbot_control/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 196,
      "name": "/szarbot_safety_controller/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 197,
      "name": "/tiered_nav_conn_graph/add_edge",
      "requestSchema": "gch_tiered_nav/Edge e\nbool bidirectional\n\n================================================================================\nMSG: gch_tiered_nav/Edge\ngch_tiered_nav/RobotPosition map1\ngch_tiered_nav/RobotPosition map2\n================================================================================\nMSG: gch_tiered_nav/RobotPosition\nstring map_name\ngeometry_msgs/Transform t\n================================================================================\nMSG: geometry_msgs/Transform\n# This represents the transform between two coordinate frames in free space.\n\nVector3 translation\nQuaternion rotation\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space.\n\n# This is semantically different than a point.\n# A vector is always anchored at the origin.\n# When a transform is applied to a vector, only the rotational component is applied.\n\nfloat64 x\nfloat64 y\nfloat64 z\n",
      "responseSchema": "\nbool result\nstring err",
      "type": "gch_tiered_nav/srv/AddEdge"
  },
  {
      "id": 198,
      "name": "/tiered_nav_conn_graph/add_map",
      "requestSchema": "gch_tiered_nav/Map map\n\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "responseSchema": "\nbool result",
      "type": "gch_tiered_nav/srv/AddMap"
  },
  {
      "id": 199,
      "name": "/tiered_nav_conn_graph/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 200,
      "name": "/tiered_nav_conn_graph/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 201,
      "name": "/tiered_nav_conn_graph/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 202,
      "name": "/tiered_nav_conn_graph/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 203,
      "name": "/tiered_nav_conn_graph/list_edges",
      "requestSchema": "",
      "responseSchema": "\ngch_tiered_nav/Edge[] edges\n================================================================================\nMSG: gch_tiered_nav/Edge\ngch_tiered_nav/RobotPosition map1\ngch_tiered_nav/RobotPosition map2\n================================================================================\nMSG: gch_tiered_nav/RobotPosition\nstring map_name\ngeometry_msgs/Transform t\n================================================================================\nMSG: geometry_msgs/Transform\n# This represents the transform between two coordinate frames in free space.\n\nVector3 translation\nQuaternion rotation\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space.\n\n# This is semantically different than a point.\n# A vector is always anchored at the origin.\n# When a transform is applied to a vector, only the rotational component is applied.\n\nfloat64 x\nfloat64 y\nfloat64 z\n",
      "type": "gch_tiered_nav/srv/ListEdges"
  },
  {
      "id": 204,
      "name": "/tiered_nav_conn_graph/list_maps",
      "requestSchema": "",
      "responseSchema": "\ngch_tiered_nav/Map[] maps\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "type": "gch_tiered_nav/srv/ListMaps"
  },
  {
      "id": 205,
      "name": "/tiered_nav_conn_graph/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 206,
      "name": "/tiered_nav_conn_graph/query_map",
      "requestSchema": "string map_name\n",
      "responseSchema": "\ngch_tiered_nav/Map map\nbool result\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "type": "gch_tiered_nav/srv/QueryMapInfo"
  },
  {
      "id": 207,
      "name": "/tiered_nav_conn_graph/query_path",
      "requestSchema": "string from_map\nstring to_map\n",
      "responseSchema": "\nbool result\nstring err\ngch_tiered_nav/Edge[] path\n================================================================================\nMSG: gch_tiered_nav/Edge\ngch_tiered_nav/RobotPosition map1\ngch_tiered_nav/RobotPosition map2\n================================================================================\nMSG: gch_tiered_nav/RobotPosition\nstring map_name\ngeometry_msgs/Transform t\n================================================================================\nMSG: geometry_msgs/Transform\n# This represents the transform between two coordinate frames in free space.\n\nVector3 translation\nQuaternion rotation\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space.\n\n# This is semantically different than a point.\n# A vector is always anchored at the origin.\n# When a transform is applied to a vector, only the rotational component is applied.\n\nfloat64 x\nfloat64 y\nfloat64 z\n",
      "type": "gch_tiered_nav/srv/QueryPath"
  },
  {
      "id": 208,
      "name": "/tiered_nav_conn_graph/rm_edge",
      "requestSchema": "string from_map\nstring to_map\n",
      "responseSchema": "\nbool result",
      "type": "gch_tiered_nav/srv/RmEdge"
  },
  {
      "id": 209,
      "name": "/tiered_nav_conn_graph/rm_map",
      "requestSchema": "string map\n",
      "responseSchema": "\nbool result",
      "type": "gch_tiered_nav/srv/RmMap"
  },
  {
      "id": 210,
      "name": "/tiered_nav_conn_graph/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 211,
      "name": "/tiered_nav_conn_graph/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 212,
      "name": "/tiered_nav_state_machine/add_cur_pose_as_edge",
      "requestSchema": "# Add an edge between current map and last map using recorded position between map switching\n",
      "responseSchema": "\nuint8 RESULT_SUCCESS = 0\nuint8 LAST_POSE_UNAVAILABLE = 1\nuint8 CUR_POSE_UNAVAILABLE = 2\nuint8 ADD_EDGE_TO_GRAPH_FAILED = 3\n\nuint8 result",
      "type": "gch_tiered_nav/srv/AddCurPoseAsEdge"
  },
  {
      "id": 213,
      "name": "/tiered_nav_state_machine/get_grid_map",
      "requestSchema": "gch_tiered_nav/Map info\n\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "responseSchema": "\nbool result\nnav_msgs/OccupancyGrid map\n\n================================================================================\nMSG: nav_msgs/OccupancyGrid\n# This represents a 2-D grid map\nstd_msgs/Header header\n\n# MetaData for the map\nMapMetaData info\n\n# The map data, in row-major order, starting with (0,0). \n# Cell (1, 0) will be listed second, representing the next cell in the x direction. \n# Cell (0, 1) will be at the index equal to info.width, followed by (1, 1).\n# The values inside are application dependent, but frequently, \n# 0 represents unoccupied, 1 represents definitely occupied, and\n# -1 represents unknown. \nint8[] data\n\n================================================================================\nMSG: nav_msgs/MapMetaData\n# This hold basic information about the characteristics of the OccupancyGrid\n\n# The time at which the map was loaded\nbuiltin_interfaces/Time map_load_time\n\n# The map resolution [m/cell]\nfloat32 resolution\n\n# Map width [cells]\nuint32 width\n\n# Map height [cells]\nuint32 height\n\n# The origin of the map [m, m, rad].  This is the real-world pose of the\n# bottom left corner of cell (0,0) in the map.\ngeometry_msgs/Pose origin\n\n================================================================================\nMSG: builtin_interfaces/Time\n# This message communicates ROS Time defined here:\n# https://design.ros2.org/articles/clock_and_time.html\n\n# The seconds component, valid over all int32 values.\nint32 sec\n\n# The nanoseconds component, valid in the range [0, 1e9).\nuint32 nanosec\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of position and orientation.\n\nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data\n# in a particular coordinate frame.\n\n# Two-integer timestamp that is expressed as seconds and nanoseconds.\nbuiltin_interfaces/Time stamp\n\n# Transform frame with which this data is associated.\nstring frame_id\n",
      "type": "gch_tiered_nav/srv/GetGridMap"
  },
  {
      "id": 214,
      "name": "/tiered_nav_state_machine/load_map",
      "requestSchema": "gch_tiered_nav/RobotPosition p\n\n================================================================================\nMSG: gch_tiered_nav/RobotPosition\nstring map_name\ngeometry_msgs/Transform t\n================================================================================\nMSG: geometry_msgs/Transform\n# This represents the transform between two coordinate frames in free space.\n\nVector3 translation\nQuaternion rotation\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space.\n\n# This is semantically different than a point.\n# A vector is always anchored at the origin.\n# When a transform is applied to a vector, only the rotational component is applied.\n\nfloat64 x\nfloat64 y\nfloat64 z\n",
      "responseSchema": "\nbool result\ngch_tiered_nav/Map map\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "type": "gch_tiered_nav/srv/LoadMap"
  },
  {
      "id": 215,
      "name": "/tiered_nav_state_machine/query_path_to_map",
      "requestSchema": "string to_map\n",
      "responseSchema": "\nbool result\nstring err\ngch_tiered_nav/Edge[] path\ngch_tiered_nav/Map starting_map\n================================================================================\nMSG: gch_tiered_nav/Edge\ngch_tiered_nav/RobotPosition map1\ngch_tiered_nav/RobotPosition map2\n================================================================================\nMSG: gch_tiered_nav/RobotPosition\nstring map_name\ngeometry_msgs/Transform t\n================================================================================\nMSG: geometry_msgs/Transform\n# This represents the transform between two coordinate frames in free space.\n\nVector3 translation\nQuaternion rotation\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space.\n\n# This is semantically different than a point.\n# A vector is always anchored at the origin.\n# When a transform is applied to a vector, only the rotational component is applied.\n\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "type": "gch_tiered_nav/srv/QueryPathToMap"
  },
  {
      "id": 216,
      "name": "/tiered_nav_state_machine/rm_map",
      "requestSchema": "string map\n",
      "responseSchema": "\nbool result",
      "type": "gch_tiered_nav/srv/RmMap"
  },
  {
      "id": 217,
      "name": "/transform_listener_impl_559b145f20/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 218,
      "name": "/velocity_smoother/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
  },
  {
      "id": 219,
      "name": "/velocity_smoother/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 220,
      "name": "/velocity_smoother/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
  },
  {
      "id": 221,
      "name": "/velocity_smoother/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 222,
      "name": "/velocity_smoother/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 223,
      "name": "/velocity_smoother/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 224,
      "name": "/velocity_smoother/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
  },
  {
      "id": 225,
      "name": "/velocity_smoother/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 226,
      "name": "/velocity_smoother/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 227,
      "name": "/velocity_smoother/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 228,
      "name": "/velocity_smoother/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 229,
      "name": "/velocity_smoother/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 230,
      "name": "/waypoint_follower/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
  },
  {
      "id": 231,
      "name": "/waypoint_follower/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 232,
      "name": "/waypoint_follower/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
  },
  {
      "id": 233,
      "name": "/waypoint_follower/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 234,
      "name": "/waypoint_follower/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 235,
      "name": "/waypoint_follower/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 236,
      "name": "/waypoint_follower/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
  },
  {
      "id": 237,
      "name": "/waypoint_follower/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
  },
  {
      "id": 238,
      "name": "/waypoint_follower/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 239,
      "name": "/waypoint_follower/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 240,
      "name": "/waypoint_follower/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  },
  {
      "id": 241,
      "name": "/waypoint_follower/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
  },
  {
      "id": 242,
      "name": "/controller_manager/configure_controller",
      "requestSchema": "# The ConfigureController service allows you to configure a single controller\n# inside controller_manager\n\n# To configure a controller, specify the \"name\" of the controller.\n# The return value \"ok\" indicates if the controller was successfully\n# configured or not.\n\nstring name\n",
      "responseSchema": "\nbool ok\n",
      "type": "controller_manager_msgs/srv/ConfigureController"
  },
  {
      "id": 243,
      "name": "/controller_manager/list_controller_types",
      "requestSchema": "# The ListControllers service returns a list of controller types that are known\n# to the controller manager plugin mechanism.\n\n",
      "responseSchema": "\nstring[] types\nstring[] base_classes\n",
      "type": "controller_manager_msgs/srv/ListControllerTypes"
  },
  {
      "id": 244,
      "name": "/controller_manager/list_controllers",
      "requestSchema": "# The ListControllers service returns a list of controller names/states/types of the\n# controllers that are loaded inside the controller_manager.\n\n",
      "responseSchema": "\ncontroller_manager_msgs/ControllerState[] controller\n\n================================================================================\nMSG: controller_manager_msgs/ControllerState\nstring name        # controller name\nstring state        # controller state: unconfigured, inactive, active, or finalized\nstring type        # the controller class name, e.g. joint_trajectory_controller/JointTrajectoryController\nstring[] claimed_interfaces        # command interfaces currently owned by controller\nstring[] required_command_interfaces        # command interfaces required by controller\nstring[] required_state_interfaces        # state interfaces required by controller\nbool is_chainable        # specifies whether or not controller can export references for a controller chain\nbool is_chained        # specifies whether or not controller's exported references are claimed by another controller\nstring[] reference_interfaces        # references to be exported (only applicable if is_chainable is true)\nChainConnection[] chain_connections        # specifies list of controllers and their exported references that the controller is chained to\n\n================================================================================\nMSG: controller_manager_msgs/ChainConnection\nstring name        # name of controller exporting reference_interfaces\nstring[] reference_interfaces        # list of reference exported by controller\n",
      "type": "controller_manager_msgs/srv/ListControllers"
  },
  {
      "id": 245,
      "name": "/controller_manager/list_hardware_components",
      "requestSchema": "# The ListHardwareComponents service returns a list of hardware HardwareComponentsState.\n# This will convey name, component_type, state and type of the components\n# that are loaded inside the resource_manager.\n\n",
      "responseSchema": "\nHardwareComponentState[] component\n\n================================================================================\nMSG: controller_manager_msgs/HardwareComponentState\nstring name\nstring type\nstring class_type  # DEPRECATED\nstring plugin_name\nlifecycle_msgs/State state\nHardwareInterface[] command_interfaces\nHardwareInterface[] state_interfaces\n\n================================================================================\nMSG: controller_manager_msgs/HardwareInterface\nstring name\nbool is_available\nbool is_claimed\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "controller_manager_msgs/srv/ListHardwareComponents"
  },
  {
      "id": 246,
      "name": "/controller_manager/list_hardware_interfaces",
      "requestSchema": "\n",
      "responseSchema": "\nHardwareInterface[] command_interfaces\nHardwareInterface[] state_interfaces\n\n================================================================================\nMSG: controller_manager_msgs/HardwareInterface\nstring name\nbool is_available\nbool is_claimed\n",
      "type": "controller_manager_msgs/srv/ListHardwareInterfaces"
  },
  {
      "id": 247,
      "name": "/controller_manager/load_controller",
      "requestSchema": "# The LoadController service allows you to load a single controller\n# inside controller_manager\n\n# To load a controller, specify the \"name\" of the controller.\n# The return value \"ok\" indicates if the controller was successfully\n# constructed and initialized or not.\n\nstring name\n",
      "responseSchema": "\nbool ok\n",
      "type": "controller_manager_msgs/srv/LoadController"
  },
  {
      "id": 248,
      "name": "/controller_manager/reload_controller_libraries",
      "requestSchema": "# The ReloadControllerLibraries service will reload all controllers that are available in\n# the system as plugins\n\n# Reloading libraries only works if there are no controllers loaded. If there\n# are still some controllers loaded, the reloading will fail.\n# If this bool is set to true, all loaded controllers will get\n# killed automatically, and the reloading can succeed.\nbool force_kill\n",
      "responseSchema": "\nbool ok\n",
      "type": "controller_manager_msgs/srv/ReloadControllerLibraries"
  },
  {
      "id": 249,
      "name": "/controller_manager/set_hardware_component_state",
      "requestSchema": "# The SetHardwareComponentState service allows to control life-cycle of a single hardware component.\n# Supported states are defined in the design document of LifecycleNodes available at:\n# https://design.ros2.org/articles/node_lifecycle.html\n# To control life-cycle of a hardware component, specify its \"name\" and \"target_state\".\n# Target state may be defined by \"id\" using a constant from `lifecycle_msgs/msg/State` or a label\n# using definitions from `hardware_interface/types/lifecycle_state_names.hpp` file.\n# The return value \"ok\" indicates if the component has successfully changed its state to \"target_state\".\n# The return value \"state\" returns current state of the hardware component.\n\nstring name\nlifecycle_msgs/State target_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "responseSchema": "\nbool ok\nlifecycle_msgs/State state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "controller_manager_msgs/srv/SetHardwareComponentState"
  },
  {
      "id": 250,
      "name": "/controller_manager/switch_controller",
      "requestSchema": "# The SwitchController service allows you deactivate a number of controllers\n# and activate a number of controllers, all in one single timestep of the\n# controller manager's control loop.\n\n# To switch controllers, specify\n#  * the list of controller names to activate,\n#  * the list of controller names to deactivate, and\n#  * the strictness (BEST_EFFORT or STRICT)\n#    * STRICT means that switching will fail if anything goes wrong (an invalid\n#      controller name, a controller that failed to activate, etc. )\n#    * BEST_EFFORT means that even when something goes wrong with on controller,\n#      the service will still try to activate/stop the remaining controllers\n#  * activate the controllers as soon as their hardware dependencies are ready, will\n#    wait for all interfaces to be ready otherwise\n#  * the timeout before aborting pending controllers. Zero for infinite\n\n# The return value \"ok\" indicates if the controllers were switched\n# successfully or not.  The meaning of success depends on the\n# specified strictness.\n\n\nstring[] activate_controllers\nstring[] deactivate_controllers\nint32 strictness\nint32 BEST_EFFORT=1\nint32 STRICT=2\nbool activate_asap\nbuiltin_interfaces/Duration timeout\n\n================================================================================\nMSG: builtin_interfaces/Duration\n# Duration defines a period between two time points.\n# Messages of this datatype are of ROS Time following this design:\n# https://design.ros2.org/articles/clock_and_time.html\n\n# Seconds component, range is valid over any possible int32 value.\nint32 sec\n\n# Nanoseconds component in the range of [0, 1e9).\nuint32 nanosec\n",
      "responseSchema": "\nbool ok\n",
      "type": "controller_manager_msgs/srv/SwitchController"
  },
  {
      "id": 251,
      "name": "/controller_manager/unload_controller",
      "requestSchema": "# The UnloadController service allows you to unload a single controller\n# from controller_manager\n\n# To unload a controller, specify the \"name\" of the controller.\n# The return value \"ok\" indicates if the controller was successfully\n# unloaded or not\n\nstring name\n",
      "responseSchema": "\nbool ok\n",
      "type": "controller_manager_msgs/srv/UnloadController"
  },
  {
      "id": 252,
      "name": "/joint_state_broadcaster/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
  },
  {
      "id": 253,
      "name": "/joint_state_broadcaster/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
  },
  {
      "id": 254,
      "name": "/joint_state_broadcaster/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
  },
  {
      "id": 255,
      "name": "/joint_state_broadcaster/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
  },
  {
      "id": 256,
      "name": "/joint_state_broadcaster/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
  },
  {
      "id": 257,
      "name": "/joint_state_broadcaster/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was a failure. On success, the contents of this field\n# are undefined.  This should only be used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
  }
]