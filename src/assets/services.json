{
  "op": "advertiseServices",
  "services": [
    {
      "id": 224,
      "name": "/waypoint_follower/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 223,
      "name": "/waypoint_follower/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 222,
      "name": "/waypoint_follower/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 221,
      "name": "/waypoint_follower/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 220,
      "name": "/waypoint_follower/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 219,
      "name": "/waypoint_follower/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
    },
    {
      "id": 218,
      "name": "/waypoint_follower/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 217,
      "name": "/waypoint_follower/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 216,
      "name": "/waypoint_follower/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 215,
      "name": "/waypoint_follower/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
    },
    {
      "id": 214,
      "name": "/waypoint_follower/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 213,
      "name": "/waypoint_follower/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
    },
    {
      "id": 212,
      "name": "/velocity_smoother/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 211,
      "name": "/velocity_smoother/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 210,
      "name": "/velocity_smoother/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 209,
      "name": "/velocity_smoother/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 208,
      "name": "/velocity_smoother/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 207,
      "name": "/velocity_smoother/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
    },
    {
      "id": 206,
      "name": "/velocity_smoother/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 205,
      "name": "/velocity_smoother/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 204,
      "name": "/velocity_smoother/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 203,
      "name": "/velocity_smoother/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
    },
    {
      "id": 202,
      "name": "/velocity_smoother/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 201,
      "name": "/velocity_smoother/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
    },
    {
      "id": 200,
      "name": "/transform_listener_impl_7f7a180027d0/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 199,
      "name": "/tiered_nav_state_machine/switch_mode",
      "requestSchema": "uint8 MODE_IDLE = 0\nuint8 MODE_MAPPING = 1\nuint8 MODE_LOCALIZATION = 2\nuint8 MODE_QUERY = 255\n\nuint8 mode\nuint8 map_type # map type in mapping mode\n",
      "responseSchema": "\nuint8 current_mode\nbool result",
      "type": "gch_tiered_nav/srv/SwitchMode"
    },
    {
      "id": 198,
      "name": "/tiered_nav_state_machine/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 197,
      "name": "/tiered_nav_state_machine/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 196,
      "name": "/tiered_nav_state_machine/save_map",
      "requestSchema": "string name\n",
      "responseSchema": "\nbool result\n",
      "type": "gch_tiered_nav/srv/SaveMap"
    },
    {
      "id": 195,
      "name": "/tiered_nav_state_machine/query_path_to_map",
      "requestSchema": "string to_map\n",
      "responseSchema": "\nbool result\nstring err\ngch_tiered_nav/Edge[] path\ngch_tiered_nav/Map starting_map\n================================================================================\nMSG: gch_tiered_nav/Edge\ngch_tiered_nav/RobotPosition map1\ngch_tiered_nav/RobotPosition map2\n================================================================================\nMSG: gch_tiered_nav/RobotPosition\nstring map_name\ngeometry_msgs/Transform t\n================================================================================\nMSG: geometry_msgs/Transform\n# This represents the transform between two coordinate frames in free space.\n\nVector3 translation\nQuaternion rotation\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space.\n\n# This is semantically different than a point.\n# A vector is always anchored at the origin.\n# When a transform is applied to a vector, only the rotational component is applied.\n\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "type": "gch_tiered_nav/srv/QueryPathToMap"
    },
    {
      "id": 194,
      "name": "/tiered_nav_state_machine/load_map",
      "requestSchema": "gch_tiered_nav/RobotPosition p\n\n================================================================================\nMSG: gch_tiered_nav/RobotPosition\nstring map_name\ngeometry_msgs/Transform t\n================================================================================\nMSG: geometry_msgs/Transform\n# This represents the transform between two coordinate frames in free space.\n\nVector3 translation\nQuaternion rotation\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space.\n\n# This is semantically different than a point.\n# A vector is always anchored at the origin.\n# When a transform is applied to a vector, only the rotational component is applied.\n\nfloat64 x\nfloat64 y\nfloat64 z\n",
      "responseSchema": "\nbool result\ngch_tiered_nav/Map map\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "type": "gch_tiered_nav/srv/LoadMap"
    },
    {
      "id": 193,
      "name": "/tiered_nav_state_machine/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 192,
      "name": "/tiered_nav_state_machine/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 191,
      "name": "/tiered_nav_state_machine/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 190,
      "name": "/tiered_nav_state_machine/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 189,
      "name": "/tiered_nav_state_machine/get_grid_map",
      "requestSchema": "gch_tiered_nav/Map info\n\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "responseSchema": "\nbool result\nnav_msgs/OccupancyGrid map\n\n================================================================================\nMSG: nav_msgs/OccupancyGrid\n# This represents a 2-D grid map\nstd_msgs/Header header\n\n# MetaData for the map\nMapMetaData info\n\n# The map data, in row-major order, starting with (0,0). \n# Cell (1, 0) will be listed second, representing the next cell in the x direction. \n# Cell (0, 1) will be at the index equal to info.width, followed by (1, 1).\n# The values inside are application dependent, but frequently, \n# 0 represents unoccupied, 1 represents definitely occupied, and\n# -1 represents unknown. \nint8[] data\n\n================================================================================\nMSG: nav_msgs/MapMetaData\n# This hold basic information about the characteristics of the OccupancyGrid\n\n# The time at which the map was loaded\nbuiltin_interfaces/Time map_load_time\n\n# The map resolution [m/cell]\nfloat32 resolution\n\n# Map width [cells]\nuint32 width\n\n# Map height [cells]\nuint32 height\n\n# The origin of the map [m, m, rad].  This is the real-world pose of the\n# bottom left corner of cell (0,0) in the map.\ngeometry_msgs/Pose origin\n\n================================================================================\nMSG: builtin_interfaces/Time\n# This message communicates ROS Time defined here:\n# https://design.ros2.org/articles/clock_and_time.html\n\n# The seconds component, valid over all int32 values.\nint32 sec\n\n# The nanoseconds component, valid in the range [0, 1e9).\nuint32 nanosec\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of position and orientation.\n\nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data\n# in a particular coordinate frame.\n\n# Two-integer timestamp that is expressed as seconds and nanoseconds.\nbuiltin_interfaces/Time stamp\n\n# Transform frame with which this data is associated.\nstring frame_id\n",
      "type": "gch_tiered_nav/srv/GetGridMap"
    },
    {
      "id": 188,
      "name": "/tiered_nav_state_machine/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 187,
      "name": "/tiered_nav_state_machine/add_cur_pose_as_edge",
      "requestSchema": "# Add an edge between current map and last map using recorded position between map switching\n",
      "responseSchema": "\nuint8 RESULT_SUCCESS = 0\nuint8 LAST_POSE_UNAVAILABLE = 1\nuint8 CUR_POSE_UNAVAILABLE = 2\nuint8 ADD_EDGE_TO_GRAPH_FAILED = 3\n\nuint8 result",
      "type": "gch_tiered_nav/srv/AddCurPoseAsEdge"
    },
    {
      "id": 186,
      "name": "/tiered_nav_conn_graph/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 185,
      "name": "/tiered_nav_conn_graph/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 184,
      "name": "/tiered_nav_conn_graph/query_path",
      "requestSchema": "string from_map\nstring to_map\n",
      "responseSchema": "\nbool result\nstring err\ngch_tiered_nav/Edge[] path\n================================================================================\nMSG: gch_tiered_nav/Edge\ngch_tiered_nav/RobotPosition map1\ngch_tiered_nav/RobotPosition map2\n================================================================================\nMSG: gch_tiered_nav/RobotPosition\nstring map_name\ngeometry_msgs/Transform t\n================================================================================\nMSG: geometry_msgs/Transform\n# This represents the transform between two coordinate frames in free space.\n\nVector3 translation\nQuaternion rotation\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space.\n\n# This is semantically different than a point.\n# A vector is always anchored at the origin.\n# When a transform is applied to a vector, only the rotational component is applied.\n\nfloat64 x\nfloat64 y\nfloat64 z\n",
      "type": "gch_tiered_nav/srv/QueryPath"
    },
    {
      "id": 183,
      "name": "/tiered_nav_conn_graph/query_map",
      "requestSchema": "string map_name\n",
      "responseSchema": "\ngch_tiered_nav/Map map\nbool result\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "type": "gch_tiered_nav/srv/QueryMapInfo"
    },
    {
      "id": 182,
      "name": "/tiered_nav_conn_graph/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 181,
      "name": "/tiered_nav_conn_graph/list_maps",
      "requestSchema": "",
      "responseSchema": "\ngch_tiered_nav/Map[] maps\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "type": "gch_tiered_nav/srv/ListMaps"
    },
    {
      "id": 180,
      "name": "/tiered_nav_conn_graph/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 179,
      "name": "/tiered_nav_conn_graph/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 178,
      "name": "/tiered_nav_conn_graph/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 177,
      "name": "/tiered_nav_conn_graph/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 176,
      "name": "/tiered_nav_conn_graph/add_map",
      "requestSchema": "gch_tiered_nav/Map map\n\n================================================================================\nMSG: gch_tiered_nav/Map\nuint8 MAP_LIDAR_ONLY = 0\nuint8 MAP_LIDAR_ORB = 1\n\nuint8 NAV_DEFAULT = 0\n\nuint8 map_type\nuint8 nav_mode\nstring map_name",
      "responseSchema": "\nbool result",
      "type": "gch_tiered_nav/srv/AddMap"
    },
    {
      "id": 175,
      "name": "/tiered_nav_conn_graph/add_edge",
      "requestSchema": "gch_tiered_nav/Edge e\n\n================================================================================\nMSG: gch_tiered_nav/Edge\ngch_tiered_nav/RobotPosition map1\ngch_tiered_nav/RobotPosition map2\n================================================================================\nMSG: gch_tiered_nav/RobotPosition\nstring map_name\ngeometry_msgs/Transform t\n================================================================================\nMSG: geometry_msgs/Transform\n# This represents the transform between two coordinate frames in free space.\n\nVector3 translation\nQuaternion rotation\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space.\n\n# This is semantically different than a point.\n# A vector is always anchored at the origin.\n# When a transform is applied to a vector, only the rotational component is applied.\n\nfloat64 x\nfloat64 y\nfloat64 z\n",
      "responseSchema": "\nbool result\nstring err",
      "type": "gch_tiered_nav/srv/AddEdge"
    },
    {
      "id": 174,
      "name": "/smoother_server/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 173,
      "name": "/smoother_server/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 172,
      "name": "/smoother_server/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 171,
      "name": "/smoother_server/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 170,
      "name": "/smoother_server/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 169,
      "name": "/smoother_server/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
    },
    {
      "id": 168,
      "name": "/smoother_server/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 167,
      "name": "/smoother_server/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 166,
      "name": "/smoother_server/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 165,
      "name": "/smoother_server/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
    },
    {
      "id": 164,
      "name": "/smoother_server/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 163,
      "name": "/smoother_server/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
    },
    {
      "id": 162,
      "name": "/smart_teleop/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 161,
      "name": "/smart_teleop/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 160,
      "name": "/smart_teleop/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 159,
      "name": "/smart_teleop/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 158,
      "name": "/smart_teleop/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 157,
      "name": "/smart_teleop/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
    },
    {
      "id": 156,
      "name": "/smart_teleop/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 155,
      "name": "/smart_teleop/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 154,
      "name": "/smart_teleop/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 153,
      "name": "/smart_teleop/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
    },
    {
      "id": 152,
      "name": "/smart_teleop/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 151,
      "name": "/smart_teleop/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
    },
    {
      "id": 150,
      "name": "/planner_server/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 149,
      "name": "/planner_server/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 148,
      "name": "/planner_server/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 147,
      "name": "/planner_server/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 146,
      "name": "/planner_server/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 145,
      "name": "/planner_server/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
    },
    {
      "id": 144,
      "name": "/planner_server/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 143,
      "name": "/planner_server/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 142,
      "name": "/planner_server/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 141,
      "name": "/planner_server/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
    },
    {
      "id": 140,
      "name": "/planner_server/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 139,
      "name": "/planner_server/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
    },
    {
      "id": 138,
      "name": "/nav2_container/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 137,
      "name": "/local_costmap/local_costmap/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 136,
      "name": "/local_costmap/local_costmap/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 135,
      "name": "/local_costmap/local_costmap/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 134,
      "name": "/local_costmap/local_costmap/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 133,
      "name": "/local_costmap/local_costmap/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 132,
      "name": "/local_costmap/local_costmap/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
    },
    {
      "id": 131,
      "name": "/local_costmap/local_costmap/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 130,
      "name": "/local_costmap/local_costmap/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 129,
      "name": "/local_costmap/local_costmap/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 128,
      "name": "/local_costmap/local_costmap/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
    },
    {
      "id": 59,
      "name": "/turtlebot3_laserscan/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 58,
      "name": "/turtlebot3_laserscan/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 57,
      "name": "/turtlebot3_laserscan/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 56,
      "name": "/turtlebot3_laserscan/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 55,
      "name": "/turtlebot3_laserscan/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 54,
      "name": "/turtlebot3_laserscan/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 53,
      "name": "/turtlebot3_joint_state/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 52,
      "name": "/turtlebot3_joint_state/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 51,
      "name": "/turtlebot3_joint_state/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 50,
      "name": "/turtlebot3_joint_state/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 49,
      "name": "/turtlebot3_joint_state/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 48,
      "name": "/turtlebot3_joint_state/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 47,
      "name": "/turtlebot3_joint_state/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 46,
      "name": "/turtlebot3_imu/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 45,
      "name": "/turtlebot3_imu/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 44,
      "name": "/turtlebot3_imu/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 43,
      "name": "/turtlebot3_imu/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 42,
      "name": "/turtlebot3_imu/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 41,
      "name": "/turtlebot3_imu/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 40,
      "name": "/turtlebot3_imu/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 39,
      "name": "/turtlebot3_diff_drive/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 38,
      "name": "/turtlebot3_diff_drive/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 37,
      "name": "/turtlebot3_diff_drive/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 36,
      "name": "/turtlebot3_diff_drive/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 35,
      "name": "/turtlebot3_diff_drive/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 34,
      "name": "/turtlebot3_diff_drive/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 33,
      "name": "/turtlebot3_diff_drive/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 32,
      "name": "/spawn_entity",
      "requestSchema": "string name                       # Name of the entity to be spawned (optional).\nstring xml                        # Entity XML description as a string, either URDF or SDF.\nstring robot_namespace            # Spawn robot and all ROS interfaces under this namespace\ngeometry_msgs/Pose initial_pose   # Initial entity pose.\nstring reference_frame            # initial_pose is defined relative to the frame of this entity.\n                                  # If left empty or \"world\" or \"map\", then gazebo world frame is\n                                  # used.\n                                  # If non-existent entity is specified, an error is returned\n                                  # and the entity is not spawned.\n\n================================================================================\nMSG: geometry_msgs/Pose\n# A representation of pose in free space, composed of position and orientation.\n\nPoint position\nQuaternion orientation\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Quaternion\n# This represents an orientation in free space in quaternion form.\n\nfloat64 x 0\nfloat64 y 0\nfloat64 z 0\nfloat64 w 1\n",
      "responseSchema": "\nbool success                      # Return true if spawned successfully.\nstring status_message             # Comments if available.\n",
      "type": "gazebo_msgs/srv/SpawnEntity"
    },
    {
      "id": 31,
      "name": "/robot_state_publisher/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 30,
      "name": "/robot_state_publisher/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 13,
      "name": "/foxglove_bridge_component_manager/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 12,
      "name": "/foxglove_bridge/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 11,
      "name": "/foxglove_bridge/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 10,
      "name": "/foxglove_bridge/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 9,
      "name": "/foxglove_bridge/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 8,
      "name": "/foxglove_bridge/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 7,
      "name": "/foxglove_bridge/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 6,
      "name": "/foxglove_bridge/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 5,
      "name": "/delete_entity",
      "requestSchema": "string name                       # Name of the Gazebo entity to be deleted. This can be either\n                                  # a model or a light.\n",
      "responseSchema": "\nbool success                      # Return true if deletion is successful.\nstring status_message             # Comments if available.\n",
      "type": "gazebo_msgs/srv/DeleteEntity"
    },
    {
      "id": 4,
      "name": "/clear_link_wrenches",
      "requestSchema": "string link_name   # name of the link requested. link names are prefixed by model name, e.g. pr2::base_link\n",
      "responseSchema": "\n",
      "type": "gazebo_msgs/srv/LinkRequest"
    },
    {
      "id": 3,
      "name": "/clear_joint_efforts",
      "requestSchema": "string joint_name   # name of the joint requested\n",
      "responseSchema": "\n\n",
      "type": "gazebo_msgs/srv/JointRequest"
    },
    {
      "id": 2,
      "name": "/apply_link_wrench",
      "requestSchema": "# Apply Wrench to Gazebo Link.\n# via the callback mechanism\n# all Gazebo operations are made in world frame\nstring link_name                          # Gazebo link to apply wrench (linear force and torque)\n                                          # wrench is applied in the gazebo world by default\n                                          # link names are prefixed by model name, e.g. pr2::base_link\nstring reference_frame                    # wrench is defined in the reference frame of this entity\n                                          # use inertial frame if left empty\n                                          # frame names are links prefixed by model name, e.g. pr2::base_link\ngeometry_msgs/Point  reference_point      # wrench is defined at this location in the reference frame\ngeometry_msgs/Wrench wrench               # wrench applied to the origin of the link\nbuiltin_interfaces/Time start_time        # (optional) wrench application start time (seconds)\n                                          # if start_time is not specified, or\n                                          # start_time < current time, start as soon as possible\nbuiltin_interfaces/Duration duration      # optional duration of wrench application time (seconds)\n                                          # if duration < 0, apply wrench continuously without end\n                                          # if duration = 0, do nothing\n                                          # if duration < step size, apply wrench\n                                          # for one step size\n\n================================================================================\nMSG: builtin_interfaces/Duration\n# Duration defines a period between two time points.\n# Messages of this datatype are of ROS Time following this design:\n# https://design.ros2.org/articles/clock_and_time.html\n\n# Seconds component, range is valid over any possible int32 value.\nint32 sec\n\n# Nanoseconds component in the range of [0, 1e9).\nuint32 nanosec\n\n================================================================================\nMSG: builtin_interfaces/Time\n# This message communicates ROS Time defined here:\n# https://design.ros2.org/articles/clock_and_time.html\n\n# The seconds component, valid over all int32 values.\nint32 sec\n\n# The nanoseconds component, valid in the range [0, 1e9).\nuint32 nanosec\n\n================================================================================\nMSG: geometry_msgs/Point\n# This contains the position of a point in free space\nfloat64 x\nfloat64 y\nfloat64 z\n\n================================================================================\nMSG: geometry_msgs/Wrench\n# This represents force in free space, separated into its linear and angular parts.\n\nVector3  force\nVector3  torque\n\n================================================================================\nMSG: geometry_msgs/Vector3\n# This represents a vector in free space.\n\n# This is semantically different than a point.\n# A vector is always anchored at the origin.\n# When a transform is applied to a vector, only the rotational component is applied.\n\nfloat64 x\nfloat64 y\nfloat64 z\n",
      "responseSchema": "\nbool success                              # return true if set wrench successful\nstring status_message                     # comments if available\n",
      "type": "gazebo_msgs/srv/ApplyLinkWrench"
    },
    {
      "id": 1,
      "name": "/apply_joint_effort",
      "requestSchema": "# set urdf joint effort\nstring joint_name                       # joint to apply wrench (linear force and torque)\nfloat64 effort                          # effort to apply\nbuiltin_interfaces/Time start_time      # optional wrench application start time (seconds)\n                                        # if start_time < current time, start as soon as possible\nbuiltin_interfaces/Duration  duration   # optional duration of wrench application time (seconds)\n                                        # if duration < 0, apply wrench continuously without end\n                                        # if duration = 0, do nothing\n                                        # if duration < step size, assume step size and\n                                        # display warning in status_message\n\n================================================================================\nMSG: builtin_interfaces/Duration\n# Duration defines a period between two time points.\n# Messages of this datatype are of ROS Time following this design:\n# https://design.ros2.org/articles/clock_and_time.html\n\n# Seconds component, range is valid over any possible int32 value.\nint32 sec\n\n# Nanoseconds component in the range of [0, 1e9).\nuint32 nanosec\n\n================================================================================\nMSG: builtin_interfaces/Time\n# This message communicates ROS Time defined here:\n# https://design.ros2.org/articles/clock_and_time.html\n\n# The seconds component, valid over all int32 values.\nint32 sec\n\n# The nanoseconds component, valid in the range [0, 1e9).\nuint32 nanosec\n",
      "responseSchema": "\nbool success                            # return true if effort application is successful\nstring status_message                   # comments if available\n",
      "type": "gazebo_msgs/srv/ApplyJointEffort"
    },
    {
      "id": 14,
      "name": "/gazebo/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 15,
      "name": "/gazebo/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 16,
      "name": "/gazebo/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 17,
      "name": "/gazebo/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 18,
      "name": "/gazebo/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 19,
      "name": "/gazebo/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 20,
      "name": "/gazebo/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 21,
      "name": "/get_model_list",
      "requestSchema": "",
      "responseSchema": "\nstd_msgs/Header header               # Standard metadata for higher-level stamped data types.\n                                     # * header.stamp Simulation time when data was collected.\nstring[] model_names                 # list of models in the world\nbool success                         # return true if get successful\n\n================================================================================\nMSG: std_msgs/Header\n# Standard metadata for higher-level stamped data types.\n# This is generally used to communicate timestamped data\n# in a particular coordinate frame.\n\n# Two-integer timestamp that is expressed as seconds and nanoseconds.\nbuiltin_interfaces/Time stamp\n\n# Transform frame with which this data is associated.\nstring frame_id\n\n================================================================================\nMSG: builtin_interfaces/Time\n# This message communicates ROS Time defined here:\n# https://design.ros2.org/articles/clock_and_time.html\n\n# The seconds component, valid over all int32 values.\nint32 sec\n\n# The nanoseconds component, valid in the range [0, 1e9).\nuint32 nanosec\n",
      "type": "gazebo_msgs/srv/GetModelList"
    },
    {
      "id": 22,
      "name": "/pause_physics",
      "requestSchema": "",
      "responseSchema": "\n",
      "type": "std_srvs/srv/Empty"
    },
    {
      "id": 23,
      "name": "/reset_simulation",
      "requestSchema": "",
      "responseSchema": "\n",
      "type": "std_srvs/srv/Empty"
    },
    {
      "id": 24,
      "name": "/reset_world",
      "requestSchema": "",
      "responseSchema": "\n",
      "type": "std_srvs/srv/Empty"
    },
    {
      "id": 25,
      "name": "/robot_state_publisher/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 26,
      "name": "/robot_state_publisher/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 27,
      "name": "/robot_state_publisher/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 28,
      "name": "/robot_state_publisher/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 29,
      "name": "/robot_state_publisher/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 60,
      "name": "/turtlebot3_laserscan/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 61,
      "name": "/unpause_physics",
      "requestSchema": "",
      "responseSchema": "\n",
      "type": "std_srvs/srv/Empty"
    },
    {
      "id": 62,
      "name": "/launch_ros_15507/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 63,
      "name": "/launch_ros_15507/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 64,
      "name": "/launch_ros_15507/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 65,
      "name": "/launch_ros_15507/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 66,
      "name": "/launch_ros_15507/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 67,
      "name": "/launch_ros_15507/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 68,
      "name": "/launch_ros_15507/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 69,
      "name": "/behavior_server/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
    },
    {
      "id": 70,
      "name": "/behavior_server/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 71,
      "name": "/behavior_server/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
    },
    {
      "id": 72,
      "name": "/behavior_server/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 73,
      "name": "/behavior_server/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 74,
      "name": "/behavior_server/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 75,
      "name": "/behavior_server/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
    },
    {
      "id": 76,
      "name": "/behavior_server/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 77,
      "name": "/behavior_server/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 78,
      "name": "/behavior_server/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 79,
      "name": "/behavior_server/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 80,
      "name": "/behavior_server/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 81,
      "name": "/bt_navigator/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
    },
    {
      "id": 82,
      "name": "/bt_navigator/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 83,
      "name": "/bt_navigator/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
    },
    {
      "id": 84,
      "name": "/bt_navigator/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 85,
      "name": "/bt_navigator/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 86,
      "name": "/bt_navigator/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 87,
      "name": "/bt_navigator/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
    },
    {
      "id": 88,
      "name": "/bt_navigator/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 89,
      "name": "/bt_navigator/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 90,
      "name": "/bt_navigator/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 91,
      "name": "/bt_navigator/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 92,
      "name": "/bt_navigator/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 93,
      "name": "/controller_server/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
    },
    {
      "id": 94,
      "name": "/controller_server/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 95,
      "name": "/controller_server/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
    },
    {
      "id": 96,
      "name": "/controller_server/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 97,
      "name": "/controller_server/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 98,
      "name": "/controller_server/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 99,
      "name": "/controller_server/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
    },
    {
      "id": 100,
      "name": "/controller_server/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 101,
      "name": "/controller_server/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 102,
      "name": "/controller_server/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 103,
      "name": "/controller_server/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 104,
      "name": "/controller_server/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 105,
      "name": "/global_costmap/global_costmap/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
    },
    {
      "id": 106,
      "name": "/global_costmap/global_costmap/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 107,
      "name": "/global_costmap/global_costmap/get_available_states",
      "requestSchema": "",
      "responseSchema": "\n# Array of possible states that can be transitioned to.\nState[] available_states\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableStates"
    },
    {
      "id": 108,
      "name": "/global_costmap/global_costmap/get_available_transitions",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 109,
      "name": "/global_costmap/global_costmap/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 110,
      "name": "/global_costmap/global_costmap/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 111,
      "name": "/global_costmap/global_costmap/get_state",
      "requestSchema": "",
      "responseSchema": "\n# The current state-machine state of the node.\nState current_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetState"
    },
    {
      "id": 112,
      "name": "/global_costmap/global_costmap/get_transition_graph",
      "requestSchema": "",
      "responseSchema": "\n# An array of the possible start_state-goal_state transitions\nTransitionDescription[] available_transitions\n\n================================================================================\nMSG: lifecycle_msgs/TransitionDescription\n# The transition id and label of this description.\nTransition transition\n\n# The current state from which this transition transitions.\nState start_state\n\n# The desired target state of this transition.\nState goal_state\n\n================================================================================\nMSG: lifecycle_msgs/State\n# Primary state definitions as depicted in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# These are the primary states. State changes can only be requested when the\n# node is in one of these states.\n\n# Indicates state has not yet been set.\nuint8 PRIMARY_STATE_UNKNOWN = 0\n\n# This is the life cycle state the node is in immediately after being\n# instantiated.\nuint8 PRIMARY_STATE_UNCONFIGURED = 1\n\n# This state represents a node that is not currently performing any processing.\nuint8 PRIMARY_STATE_INACTIVE = 2\n\n# This is the main state of the node's life cycle. While in this state, the node\n# performs any processing, responds to service requests, reads and processes\n# data, produces output, etc.\nuint8 PRIMARY_STATE_ACTIVE = 3\n\n# The finalized state is the state in which the node ends immediately before\n# being destroyed.\nuint8 PRIMARY_STATE_FINALIZED = 4\n\n# Temporary intermediate states. When a transition is requested, the node\n# changes its state into one of these states.\n\n# In this transition state the node's onConfigure callback will be called to\n# allow the node to load its configuration and conduct any required setup.\nuint8 TRANSITION_STATE_CONFIGURING = 10\n\n# In this transition state the node's callback onCleanup will be called to clear\n# all state and return the node to a functionally equivalent state as when\n# first created.\nuint8 TRANSITION_STATE_CLEANINGUP = 11\n\n# In this transition state the callback onShutdown will be executed to do any\n# cleanup necessary before destruction.\nuint8 TRANSITION_STATE_SHUTTINGDOWN = 12\n\n# In this transition state the callback onActivate will be executed to do any\n# final preparations to start executing.\nuint8 TRANSITION_STATE_ACTIVATING = 13\n\n# In this transition state the callback onDeactivate will be executed to do any\n# cleanup to start executing, and reverse the onActivate changes.\nuint8 TRANSITION_STATE_DEACTIVATING = 14\n\n# This transition state is where any error may be cleaned up.\nuint8 TRANSITION_STATE_ERRORPROCESSING = 15\n\n# The state id value from the above definitions.\nuint8 id\n\n# A text label of the state.\nstring label\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "type": "lifecycle_msgs/srv/GetAvailableTransitions"
    },
    {
      "id": 113,
      "name": "/global_costmap/global_costmap/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 114,
      "name": "/global_costmap/global_costmap/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 115,
      "name": "/global_costmap/global_costmap/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 116,
      "name": "/global_costmap/global_costmap/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 117,
      "name": "/lifecycle_manager_navigation/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    },
    {
      "id": 118,
      "name": "/lifecycle_manager_navigation/get_parameter_types",
      "requestSchema": "# A list of parameter names.\n# TODO(wjwwood): link to parameter naming rules.\nstring[] names\n\n",
      "responseSchema": "\n# List of types which is the same length and order as the provided names.\n#\n# The type enum is defined in ParameterType.msg. ParameterType.PARAMETER_NOT_SET\n# indicates that the parameter is not currently set.\nuint8[] types\n",
      "type": "rcl_interfaces/srv/GetParameterTypes"
    },
    {
      "id": 119,
      "name": "/lifecycle_manager_navigation/get_parameters",
      "requestSchema": "# TODO(wjwwood): Decide on the rules for grouping, nodes, and parameter \"names\"\n# in general, then link to that.\n#\n# For more information about parameters and naming rules, see:\n# https://design.ros2.org/articles/ros_parameters.html\n# https://github.com/ros2/design/pull/241\n\n# A list of parameter names to get.\nstring[] names\n\n",
      "responseSchema": "\n# List of values which is the same length and order as the provided names. If a\n# parameter was not yet set, the value will have PARAMETER_NOT_SET as the\n# type.\nParameterValue[] values\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "type": "rcl_interfaces/srv/GetParameters"
    },
    {
      "id": 120,
      "name": "/lifecycle_manager_navigation/get_type_description",
      "requestSchema": "# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# REP-2011 RIHS hash string.\nstring type_hash\n\n# Whether to return the original idl/msg/etc. source file(s) in the response.\nbool include_type_sources true\n",
      "responseSchema": "\n# True if the type description information is available and populated in the response.\n# If false, all other fields except `failure_reason` are considered undefined.\nbool successful\n# If `successful` is false, contains a reason for failure.\n# If `successful` is true, this is left empty.\nstring failure_reason\n\n# The parsed type description which can be used programmatically.\nTypeDescription type_description\n\n# A list containing the interface definition source text of the requested type,\n# plus all types it recursively depends on.\n# Each source text is a copy of the original contents of the\n# .msg, .srv, .action, .idl, or other file if it exists, including comments and whitespace.\n# Sources can be matched with IndividualTypeDescriptions by their `type_name`.\n# The `encoding` field of each entry informs how to interpret its contents.\nTypeSource[] type_sources\n\n# Key-value pairs of extra information.\nKeyValue[] extra_information\n\n================================================================================\nMSG: type_description_interfaces/KeyValue\n# Represents an arbitrary key-value pair for application-specific information.\n\nstring key\nstring value\n\n================================================================================\nMSG: type_description_interfaces/TypeDescription\n# Represents a complete type description, including the type itself as well as the types it references.\n\n# Description of the type.\nIndividualTypeDescription type_description\n# Descriptions of all referenced types, recursively.\nIndividualTypeDescription[] referenced_type_descriptions\n\n================================================================================\nMSG: type_description_interfaces/IndividualTypeDescription\n# Represents a single type, without the types it references, if any.\n\n# Name of the type.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 type_name\n# Fields of the type.\nField[] fields\n\n================================================================================\nMSG: type_description_interfaces/Field\n# Represents a single field in a type.\n\n# Name of the field.\nstring name\n# Type of the field, including details about the type like length, nested name, etc.\nFieldType type\n# Literal default value of the field as a string, as it appeared in the original\n# message description file, whether that be .msg/.srv/.action or .idl.\nstring default_value\n\n================================================================================\nMSG: type_description_interfaces/FieldType\n# Represents the type of a field and related meta-data.\n\n# A constant for each type supported according to:\n#   http://design.ros2.org/articles/legacy_interface_definition.html\n# and:\n#   http://design.ros2.org/articles/idl_interface_definition.html\n# Order is loosely coupled to the order of appearance in the IDL 4.2 spec:\n#  https://www.omg.org/spec/IDL/4.2\n\n# Layout of constants across the 0-255 decimal values in the uint8:\n#\n# - 000    : Reserved for \"not set\"\n# - 001-048: Primitive types, strings, and reserved space for future primitive types\n# - 049-096: Fixed sized array of primitive and string types\n# - 097-144: Bounded Sequences of primitive and string types\n# - 145-192: Unbounded Sequences of primitive and string types\n# - 193-255: Reserved space for future array/sequence-like types\n\nuint8 FIELD_TYPE_NOT_SET = 0\n\n# Nested type defined in other .msg/.idl files.\nuint8 FIELD_TYPE_NESTED_TYPE = 1\n\n# Integer Types\nuint8 FIELD_TYPE_INT8 = 2\nuint8 FIELD_TYPE_UINT8 = 3\nuint8 FIELD_TYPE_INT16 = 4\nuint8 FIELD_TYPE_UINT16 = 5\nuint8 FIELD_TYPE_INT32 = 6\nuint8 FIELD_TYPE_UINT32 = 7\nuint8 FIELD_TYPE_INT64 = 8\nuint8 FIELD_TYPE_UINT64 = 9\n\n# Floating-Point Types\nuint8 FIELD_TYPE_FLOAT = 10\nuint8 FIELD_TYPE_DOUBLE = 11\nuint8 FIELD_TYPE_LONG_DOUBLE = 12\n\n# Char and WChar Types\nuint8 FIELD_TYPE_CHAR = 13\nuint8 FIELD_TYPE_WCHAR = 14\n\n# Boolean Type\nuint8 FIELD_TYPE_BOOLEAN = 15\n\n# Byte/Octet Type\nuint8 FIELD_TYPE_BYTE = 16\n\n# String Types\nuint8 FIELD_TYPE_STRING = 17\nuint8 FIELD_TYPE_WSTRING = 18\n\n# Fixed String Types\nuint8 FIELD_TYPE_FIXED_STRING = 19\nuint8 FIELD_TYPE_FIXED_WSTRING = 20\n\n# Bounded String Types\nuint8 FIELD_TYPE_BOUNDED_STRING = 21\nuint8 FIELD_TYPE_BOUNDED_WSTRING = 22\n\n# Fixed Sized Array Types\nuint8 FIELD_TYPE_NESTED_TYPE_ARRAY = 49\nuint8 FIELD_TYPE_INT8_ARRAY = 50\nuint8 FIELD_TYPE_UINT8_ARRAY = 51\nuint8 FIELD_TYPE_INT16_ARRAY = 52\nuint8 FIELD_TYPE_UINT16_ARRAY = 53\nuint8 FIELD_TYPE_INT32_ARRAY = 54\nuint8 FIELD_TYPE_UINT32_ARRAY = 55\nuint8 FIELD_TYPE_INT64_ARRAY = 56\nuint8 FIELD_TYPE_UINT64_ARRAY = 57\nuint8 FIELD_TYPE_FLOAT_ARRAY = 58\nuint8 FIELD_TYPE_DOUBLE_ARRAY = 59\nuint8 FIELD_TYPE_LONG_DOUBLE_ARRAY = 60\nuint8 FIELD_TYPE_CHAR_ARRAY = 61\nuint8 FIELD_TYPE_WCHAR_ARRAY = 62\nuint8 FIELD_TYPE_BOOLEAN_ARRAY = 63\nuint8 FIELD_TYPE_BYTE_ARRAY = 64\nuint8 FIELD_TYPE_STRING_ARRAY = 65\nuint8 FIELD_TYPE_WSTRING_ARRAY = 66\nuint8 FIELD_TYPE_FIXED_STRING_ARRAY = 67\nuint8 FIELD_TYPE_FIXED_WSTRING_ARRAY = 68\nuint8 FIELD_TYPE_BOUNDED_STRING_ARRAY = 69\nuint8 FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70\n\n# Bounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97\nuint8 FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98\nuint8 FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99\nuint8 FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100\nuint8 FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101\nuint8 FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102\nuint8 FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103\nuint8 FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104\nuint8 FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105\nuint8 FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106\nuint8 FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107\nuint8 FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108\nuint8 FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109\nuint8 FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110\nuint8 FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111\nuint8 FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112\nuint8 FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113\nuint8 FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114\nuint8 FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115\nuint8 FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116\nuint8 FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117\nuint8 FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118\n\n# Unbounded Sequence Types\nuint8 FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145\nuint8 FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146\nuint8 FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147\nuint8 FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148\nuint8 FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149\nuint8 FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150\nuint8 FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151\nuint8 FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152\nuint8 FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153\nuint8 FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154\nuint8 FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155\nuint8 FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156\nuint8 FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157\nuint8 FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158\nuint8 FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159\nuint8 FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160\nuint8 FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161\nuint8 FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162\nuint8 FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163\nuint8 FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164\nuint8 FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165\nuint8 FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166\n\n# Identifying number for the type of the field, using one of the above constants.\nuint8 type_id 0\n\n# Only used when the type is an array or a bounded sequence.\n# In the case of an array, this is the fixed capacity of the array.\n# In the case of a bounded sequence, this is the maximum capacity of the sequence.\n# In all other cases this field is unused.\nuint64 capacity\n\n# Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.\n# In the case of a fixed string/wstring, it is the fixed length of the string.\n# In the case of a bounded string/wstring, it is the maximum capacity of the string.\n# In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.\n# In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.\n# It is not currently possible to have different string capacities per element in the array/sequence.\nuint64 string_capacity\n\n# Only used when the type is a nested type or array/sequence of nested types.\n# This is limited to 255 characters.\n# TODO(wjwwood): this 255 character limit was chosen due to this being the limit\n#   for DDSI-RTPS based middlewares, which is the most commonly used right now.\n#   We lack a ROS 2 specific limit in our design documents, but we should update\n#   this and/or link to the design doc when that is available.\nstring<=255 nested_type_name\n\n================================================================================\nMSG: type_description_interfaces/TypeSource\n# Represents the original source of a ROS 2 interface definition.\n\n# ROS interface type name, in PACKAGE/NAMESPACE/TYPENAME format.\nstring type_name\n\n# The type of the original source file, typically matching the file extension.\n# Well-known encodings: \"idl\", \"msg\", \"srv\", \"action\", \"dynamic\", \"implicit\".\n# \"dynamic\" specifies a type created programmatically by a user, thus having no source.\n# \"implicit\" specifies a type created automatically as a subtype of a\n# complex type (service or action) - such as the request message for a service.\n# Implicit types will have no contents, the full source will be available on the parent srv/action.\nstring encoding\n\n# Dumped contents of the interface definition source file.\n# If `encoding` is \"dynamic\" or \"implicit\", this field will be empty.\nstring raw_file_contents\n",
      "type": "type_description_interfaces/srv/GetTypeDescription"
    },
    {
      "id": 121,
      "name": "/lifecycle_manager_navigation/is_active",
      "requestSchema": "",
      "responseSchema": "\nbool success   # indicate successful run of triggered service\nstring message # informational, e.g. for error messages\n",
      "type": "std_srvs/srv/Trigger"
    },
    {
      "id": 122,
      "name": "/lifecycle_manager_navigation/list_parameters",
      "requestSchema": "# Recursively get parameters with unlimited depth.\nuint64 DEPTH_RECURSIVE=0\n\n# The list of parameter prefixes to query.\nstring[] prefixes\n\n# Relative depth from given prefixes to return.\n#\n# Use DEPTH_RECURSIVE to get the recursive parameters and prefixes for each prefix.\nuint64 depth\n\n",
      "responseSchema": "\n# The list of parameter names and their prefixes.\nListParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/ListParametersResult\n# The resulting parameters under the given prefixes.\nstring[] names\n\n# The resulting prefixes under the given prefixes.\n# TODO(wjwwood): link to prefix definition and rules.\nstring[] prefixes\n",
      "type": "rcl_interfaces/srv/ListParameters"
    },
    {
      "id": 123,
      "name": "/lifecycle_manager_navigation/manage_nodes",
      "requestSchema": "uint8 STARTUP = 0\nuint8 PAUSE = 1\nuint8 RESUME = 2\nuint8 RESET = 3\nuint8 SHUTDOWN = 4\n\nuint8 command\n",
      "responseSchema": "\nbool success\n",
      "type": "nav2_msgs/srv/ManageLifecycleNodes"
    },
    {
      "id": 124,
      "name": "/lifecycle_manager_navigation/set_parameters",
      "requestSchema": "# A list of parameters to set.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting each parameter succeeded or not and why.\nSetParametersResult[] results\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParameters"
    },
    {
      "id": 125,
      "name": "/lifecycle_manager_navigation/set_parameters_atomically",
      "requestSchema": "# A list of parameters to set atomically.\n#\n# This call will either set all values, or none of the values.\nParameter[] parameters\n\n\n================================================================================\nMSG: rcl_interfaces/Parameter\n# This is the message to communicate a parameter. It is an open struct with an enum in\n# the descriptor to select which value is active.\n\n# The full name of the parameter.\nstring name\n\n# The parameter's value which can be one of several types, see\n# `ParameterValue.msg` and `ParameterType.msg`.\nParameterValue value\n\n================================================================================\nMSG: rcl_interfaces/ParameterValue\n# Used to determine which of the next *_value fields are set.\n# ParameterType.PARAMETER_NOT_SET indicates that the parameter was not set\n# (if gotten) or is uninitialized.\n# Values are enumerated in `ParameterType.msg`.\n\n# The type of this parameter, which corresponds to the appropriate field below.\nuint8 type\n\n# \"Variant\" style storage of the parameter value. Only the value corresponding\n# the type field will have valid information.\n\n# Boolean value, can be either true or false.\nbool bool_value\n\n# Integer value ranging from -9,223,372,036,854,775,808 to\n# 9,223,372,036,854,775,807.\nint64 integer_value\n\n# A double precision floating point value following IEEE 754.\nfloat64 double_value\n\n# A textual value with no practical length limit.\nstring string_value\n\n# An array of bytes, used for non-textual information.\nbyte[] byte_array_value\n\n# An array of boolean values.\nbool[] bool_array_value\n\n# An array of 64-bit integer values.\nint64[] integer_array_value\n\n# An array of 64-bit floating point values.\nfloat64[] double_array_value\n\n# An array of string values.\nstring[] string_array_value\n",
      "responseSchema": "\n# Indicates whether setting all of the parameters succeeded or not and why.\nSetParametersResult result\n\n================================================================================\nMSG: rcl_interfaces/SetParametersResult\n# A true value of the same index indicates that the parameter was set\n# successfully. A false value indicates the change was rejected.\nbool successful\n\n# Reason why the setting was either successful or a failure. This should only be\n# used for logging and user interfaces.\nstring reason\n",
      "type": "rcl_interfaces/srv/SetParametersAtomically"
    },
    {
      "id": 126,
      "name": "/local_costmap/local_costmap/change_state",
      "requestSchema": "# The requested transition.\n#\n# This change state service will fail if the transition is not possible.\nTransition transition\n\n================================================================================\nMSG: lifecycle_msgs/Transition\n# Default values for transitions as described in:\n# http://design.ros2.org/articles/node_lifecycle.html\n\n# Reserved [0-9], publicly available transitions.\n# When a node is in one of these primary states, these transitions can be\n# invoked.\n\n# This transition will instantiate the node, but will not run any code beyond\n# the constructor.\nuint8 TRANSITION_CREATE = 0\n\n# The node's onConfigure callback will be called to allow the node to load its\n# configuration and conduct any required setup.\nuint8 TRANSITION_CONFIGURE = 1\n\n# The node's callback onCleanup will be called in this transition to allow the\n# node to load its configuration and conduct any required setup.\nuint8 TRANSITION_CLEANUP = 2\n\n# The node's callback onActivate will be executed to do any final preparations\n# to start executing.\nuint8 TRANSITION_ACTIVATE = 3\n\n# The node's callback onDeactivate will be executed to do any cleanup to start\n# executing, and reverse the onActivate changes.\nuint8 TRANSITION_DEACTIVATE = 4\n\n# This signals shutdown during an unconfigured state, the node's callback\n# onShutdown will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_UNCONFIGURED_SHUTDOWN  = 5\n\n# This signals shutdown during an inactive state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_INACTIVE_SHUTDOWN = 6\n\n# This signals shutdown during an active state, the node's callback onShutdown\n# will be executed to do any cleanup necessary before destruction.\nuint8 TRANSITION_ACTIVE_SHUTDOWN = 7\n\n# This transition will simply cause the deallocation of the node.\nuint8 TRANSITION_DESTROY = 8\n\n# Reserved [10-69], private transitions\n# These transitions are not publicly available and cannot be invoked by a user.\n# The following transitions are implicitly invoked based on the callback\n# feedback of the intermediate transition states.\nuint8 TRANSITION_ON_CONFIGURE_SUCCESS = 10\nuint8 TRANSITION_ON_CONFIGURE_FAILURE = 11\nuint8 TRANSITION_ON_CONFIGURE_ERROR = 12\n\nuint8 TRANSITION_ON_CLEANUP_SUCCESS = 20\nuint8 TRANSITION_ON_CLEANUP_FAILURE = 21\nuint8 TRANSITION_ON_CLEANUP_ERROR = 22\n\nuint8 TRANSITION_ON_ACTIVATE_SUCCESS = 30\nuint8 TRANSITION_ON_ACTIVATE_FAILURE = 31\nuint8 TRANSITION_ON_ACTIVATE_ERROR = 32\n\nuint8 TRANSITION_ON_DEACTIVATE_SUCCESS = 40\nuint8 TRANSITION_ON_DEACTIVATE_FAILURE = 41\nuint8 TRANSITION_ON_DEACTIVATE_ERROR = 42\n\nuint8 TRANSITION_ON_SHUTDOWN_SUCCESS = 50\nuint8 TRANSITION_ON_SHUTDOWN_FAILURE = 51\nuint8 TRANSITION_ON_SHUTDOWN_ERROR = 52\n\nuint8 TRANSITION_ON_ERROR_SUCCESS = 60\nuint8 TRANSITION_ON_ERROR_FAILURE = 61\nuint8 TRANSITION_ON_ERROR_ERROR = 62\n\n# Reserved [90-99]. Transition callback success values.\n# These return values ought to be set as a return value for each callback.\n# Depending on which return value, the transition will be executed correctly or\n# fallback/error callbacks will be triggered.\n\n# The transition callback successfully performed its required functionality.\nuint8 TRANSITION_CALLBACK_SUCCESS = 97\n\n# The transition callback failed to perform its required functionality.\nuint8 TRANSITION_CALLBACK_FAILURE = 98\n\n# The transition callback encountered an error that requires special cleanup, if\n# possible.\nuint8 TRANSITION_CALLBACK_ERROR = 99\n\n##\n## Fields\n##\n\n# The transition id from above definitions.\nuint8 id\n\n# A text label of the transition.\nstring label\n",
      "responseSchema": "\n\n# Indicates whether the service was able to initiate the state transition\nbool success\n",
      "type": "lifecycle_msgs/srv/ChangeState"
    },
    {
      "id": 127,
      "name": "/local_costmap/local_costmap/describe_parameters",
      "requestSchema": "# A list of parameters of which to get the descriptor.\nstring[] names\n\n",
      "responseSchema": "\n# A list of the descriptors of all parameters requested in the same order\n# as they were requested. This list has the same length as the list of\n# parameters requested.\nParameterDescriptor[] descriptors\n\n================================================================================\nMSG: rcl_interfaces/ParameterDescriptor\n# This is the message to communicate a parameter's descriptor.\n\n# The name of the parameter.\nstring name\n\n# Enum values are defined in the `ParameterType.msg` message.\nuint8 type\n\n# Description of the parameter, visible from introspection tools.\nstring description\n\n# Parameter constraints\n\n# Plain English description of additional constraints which cannot be expressed\n# with the available constraints, e.g. \"only prime numbers\".\n#\n# By convention, this should only be used to clarify constraints which cannot\n# be completely expressed with the parameter constraints below.\nstring additional_constraints\n\n# If 'true' then the value cannot change after it has been initialized.\nbool read_only false\n\n# If true, the parameter is allowed to change type.\nbool dynamic_typing false\n\n# If any of the following sequences are not empty, then the constraint inside of\n# them apply to this parameter.\n#\n# FloatingPointRange and IntegerRange are mutually exclusive.\n\n# FloatingPointRange consists of a from_value, a to_value, and a step.\nFloatingPointRange[<=1] floating_point_range\n\n# IntegerRange consists of a from_value, a to_value, and a step.\nIntegerRange[<=1] integer_range\n\n================================================================================\nMSG: rcl_interfaces/FloatingPointRange\n# Represents bounds and a step value for a floating point typed parameter.\n\n# Start value for valid values, inclusive.\nfloat64 from_value\n\n# End value for valid values, inclusive.\nfloat64 to_value\n\n# Size of valid steps between the from and to bound.\n# \n# Step is considered to be a magnitude, therefore negative values are treated\n# the same as positive values, and a step value of zero implies a continuous\n# range of values.\n#\n# Ideally, the step would be less than or equal to the distance between the\n# bounds, as well as an even multiple of the distance between the bounds, but\n# neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then the\n# valid values will be 1.0 and 2.0.\n#\n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}\n# then the valid values will be 2.0, 4.0, and 5.0.\nfloat64 step\n\n================================================================================\nMSG: rcl_interfaces/IntegerRange\n# Represents bounds and a step value for an integer typed parameter.\n\n# Start value for valid values, inclusive.\nint64 from_value\n\n# End value for valid values, inclusive.\nint64 to_value\n\n# Size of valid steps between the from and to bound.\n#\n# A step value of zero implies a continuous range of values. Ideally, the step\n# would be less than or equal to the distance between the bounds, as well as an\n# even multiple of the distance between the bounds, but neither are required.\n#\n# If the absolute value of the step is larger than or equal to the distance\n# between the two bounds, then the bounds will be the only valid values. e.g. if\n# the range is defined as {from_value: 1, to_value: 2, step: 5} then the valid\n# values will be 1 and 2.\n# \n# If the step is less than the distance between the bounds, but the distance is\n# not a multiple of the step, then the \"to\" bound will always be a valid value,\n# e.g. if the range is defined as {from_value: 2, to_value: 5, step: 2} then\n# the valid values will be 2, 4, and 5.\nuint64 step\n",
      "type": "rcl_interfaces/srv/DescribeParameters"
    }
  ]
}
